/*
    APRS2RRD version 0.0.2 - Software for plotting WX parameters from data
    fetched from APRS-IS
    Copyright (C) 2013 Mateusz Lubecki ; sp8ebc@interia.pl

    This software can be used as alternative to aprs.fi webpage, where WX plots
    are refreshed in unchangeable 10 minutes period, using JavaScript routines.
    Here all parameters like axis scaling, updating frequency or data and plot
    resolution can be fited by user. What is the best property of it, this
    software is fully independent of aprs.fi. It establish connection directly
    to chosen APRS-IS server and download all necesary data using filters.
    Page generated by this programme is shown in this screen:
    http://obrazki.elektroda.pl/7536191200_1391286585.png

    WARNING!!!! This is very early alpha version! All settings must be set by
    manually changing of few variables and tables (class ProgramConfig actually
    don't work). This software might be unstable and it can generate errors!

    DISCLAIMER: As you can see, source is written pourly and without some
    "good-programmer-behaviours". I intentionally put all in single file,
    because this software is directed to amateur radio operators witch are
    usually not familiar with Linux systems and programmig. I will maintain
    ease of compiling and using this programme. It is (version 0.0.2) rather
    small project and such things as try..catch, project splitting and few
    other are too sophisticated for it. Generally it is a little mix of C
    and C++ coding rules but this is purposeful action.

    This is free software, licensed under GNU-LGPL license.

*/

#include <iostream>
#include <exception>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <libconfig.h>

#define CALL "SP8EBC"
#define PASS 123456
#define MONITORED_CALL "SR9WXG"
#define APRS_SERVER "euro.aprs2.net"
#define APRS_SERVER_PORT 14580
#define RRD_SPEED_PATH "/home/aprs/chelm/predkosc.rrd"
#define RRD_GUSTS_PATH "/home/aprs/chelm/szkwaly.rrd"
#define RRD_DIRECTION_PATH "/home/aprs/chelm/kierunek.rrd"
#define PNG_SPEED_PATH "/home/www-server/chelm/predkosc.png"
#define PNG_DIRECTION_PATH "/home/www-server/chelm/kierunek.png"
#define HTML_PATH "/home/www-server/chelm/index.html"

using namespace std;

int buff_len = 0;

struct PathElement {
    char Call[10];
    unsigned char SSID;
};

class ProgramConfig {
    // klasa zawiera konfiguracje programu
    public:
        char Call[7];   // Callsign used to login into APRS Server
        unsigned int Pass;     // APRS-IS Password
        char MonitoredCall[7];  // Callsign desired to monitoring (station witch you want to plot)
        char APRSServerAddr[32];    // APRS-IS Server address
        unsigned int APRSServerPot; // APRS-IS Server port. Rember that you must choose port with "user-defined-filter" routine
        char RRDSpeedPath[123];       // Full path to RRD database with windspeed values
        char RRDGustsPath[123];
        char RRDDirectionPath[123];
        char PNGSpeedPath[123];       // Full path to generated windspeed plot
        char PNGGustsPath[123];       // Full path to generated wind gusts plot
        char PNGDirectionPath[123];   // The same as above but direction
        char HTMLPath[123];           // The same as above but it point to file where dynamical page should be generated
        /////// functions
        ProgramConfig();          // Class constructor. Zeroing all variables and strings
        void SetParameters();
};

class APRS_Packet {
    private:
    public:
        char DestAddr[7];   // Destination address, sliced from packer. In APRS it works as Device-ID
        char SrcAddr[7];    // Source address
        unsigned char SrcSSID;  // SSID of Source
        PathElement Path[5];        // Routing Path
        unsigned char PathLng;      // Number of elements in path
        char qOrigin[4];        // APRS-IS originator
        PathElement ToISOriginator;     // APRS-IS originator. It might be Igate callsign or APRS server name, if packet
                                        // was sent directly to Internet from some APRS client.
        char Data[128];         // Data from frame
        APRS_Packet();          // Class constructor. It prepares all variables by writing zeros to it
        void PrintPacketData();     // Function witch print data from processed packet
        short ParseAPRSISData(char* tInputBuffer, APRS_Packet* cTarget);
};

class WXFromPacket {
    public:
        float wind_speed;
        float wind_gusts;
        int wind_direction;
        float temperature;
        short pressure;
        short rain60;
        short rain24;
        short rain_day;
        unsigned char humidity;
    public:
        bool val;
        WXFromPacket();
        ~WXFromPacket();
        char ParseData(APRS_Packet* input);
        int CopyConvert(char sign, char* input, int* output, int* counter);
};

ProgramConfig::ProgramConfig() {
    this->Pass = 0;
    this->APRSServerPot = 0;
    memset(this->Call, 0x00, sizeof(this->Call));
    memset(this->MonitoredCall, 0x00, sizeof(this->MonitoredCall));
    memset(this->APRSServerAddr, 0x00, sizeof(this->APRSServerAddr));
    memset(this->RRDSpeedPath, 0x00, sizeof(this->RRDSpeedPath));
    memset(this->RRDDirectionPath, 0x00, sizeof(this->RRDDirectionPath));
    memset(this->RRDGustsPath, 0x00, sizeof(this->RRDGustsPath));
    memset(this->PNGSpeedPath, 0x00, sizeof(this->PNGSpeedPath));
    memset(this->PNGGustsPath, 0x00, sizeof(this->PNGGustsPath));
    memset(this->PNGDirectionPath, 0x00, sizeof(this->PNGDirectionPath));
    memset(this->HTMLPath, 0x00, sizeof(this->HTMLPath));
}

void ProgramConfig::SetParameters() {
    strcpy(this->Call, CALL);
    this->Pass = PASS;
    strcpy(this->MonitoredCall, MONITORED_CALL);
    strcpy(this->APRSServerAddr, APRS_SERVER);
    this->APRSServerPot = APRS_SERVER_PORT;
    strcpy(this->RRDSpeedPath, RRD_SPEED_PATH);
    strcpy(this->RRDDirectionPath, RRD_DIRECTION_PATH);
    strcpy(this->RRDGustsPath, RRD_GUSTS_PATH);
    strcpy(this->PNGSpeedPath, PNG_SPEED_PATH);
    strcpy(this->PNGDirectionPath, PNG_DIRECTION_PATH);
    strcpy(this->HTMLPath, HTML_PATH);
}

APRS_Packet::APRS_Packet() {
    int i;
    memset(this->DestAddr,0x00,sizeof(this->DestAddr));
    memset(this->SrcAddr,0x00,sizeof(this->SrcAddr));
    this->SrcSSID = 0;
    memset(this->Data,0x00,sizeof(this->Data));
    for (i = 0; i<=5; i++) {
        memset(this->Path[i].Call, 0x00, sizeof(this->Path[i].Call));
        this->Path[i].SSID = 0;
    }
    memset(this->ToISOriginator.Call, 0x00, sizeof(this->ToISOriginator.Call));
    this->PathLng = 0;
}

void APRS_Packet::PrintPacketData() {
    printf("----------------------------------------------- \r\n");
    printf("-- Przetworzone dane stacji: %s - %d \r\n", this->SrcAddr, this->SrcSSID);
    printf("-- Id urządzenia: %s \r\n", this->DestAddr);
    printf("-- Długość Ścieżki: %d \r\n", this->PathLng + 1);
    for (int i = 0; i<= this->PathLng; i++)
        printf("---- Element Numer: %d = %s-%d \r\n", i, this->Path[i].Call, this->Path[i].SSID);
    printf("-- Typ wysyłającego do APRS-IS: %s \r\n", this->qOrigin);
    printf("-- Wysyłający do APRS-IS: %s \r\n", this->ToISOriginator.Call);
    printf("-- Dane: %s \r\n", this->Data);
    printf("----------------------------------------------- \r\n");
}

WXFromPacket::WXFromPacket() {
    wind_speed = 0.0;
    wind_gusts = 0.0;
    wind_direction = 0;
}

WXFromPacket::~WXFromPacket() {
    if (this->val == true) {
        printf("--------- DANE POGODOWE ------- \r\n");
        printf("-- Siła wiatru: %f \r\n", this->wind_speed);
        printf("-- Porywy: %f \r\n", this->wind_gusts);
        printf("-- Kierunek: %d \r\n", this->wind_direction);
        printf("-- Temperatura: %f \r\n", this->temperature);
    }
}

char WXFromPacket::ParseData(APRS_Packet* input) {
    int i = 0;
//    int j = 0;
    int conv_temp;
//    char tempbuff[9];
    char *src;
//    memset(tempbuff, 0x00, sizeof(tempbuff));
    if (*(input->Data) != '!') {
        this->val = false;
        return -1;      // to nie sa dane pogodowe
    }
    src = input->Data;
    do {
        i++;
		if (*(src + i) == 0x00) 
			return 1;
    } while (*(src + i) != '_'); // pominiecie pozycji i przejsce od razu do danych meteo
    i++;    // przeskoczenie na pierwszy znak danych meteo
    if (this->CopyConvert('/',src,&conv_temp,&i) == 0)   // kierunek    this->wind_direction = conv_temp;
		this->wind_direction = conv_temp;
	else
		return -1;
    i++;
    if (this->CopyConvert('g',src,&conv_temp,&i) == 0)   // siła
		this->wind_speed = (float)conv_temp * 0.44;
	else
		return -1;
    i++;
    if (this->CopyConvert('t',src,&conv_temp,&i) == 0)       // porywy
		this->wind_gusts = (float)conv_temp * 0.44;
	else
		return -1;
    i++;
    if (this->CopyConvert('r',src,&conv_temp,&i) == 0)   // temperatura
		this->temperature = ((float)conv_temp - 32) / 9 * 5;
	else
		return -1;
    i++;
    if (this->CopyConvert('p',src,&conv_temp,&i) == 0)   // deszcz przez ostania godzine
		this->rain60 = conv_temp;
	else
		return -1;
    this->val = true;
    return 0;
}

int WXFromPacket::CopyConvert(char sign, char* input, int* output, int* counter) {
    int i = 0;
    int j = 0;
    char tempbuff[9];
    memset(tempbuff, 0x00, sizeof(tempbuff));
    do {
		if (*(input + *counter) == 0x00)
			return -1;
        // siła wiatru
        tempbuff[j] = *(input + *counter);
        *counter += 1;
        j++;
    } while(*(input + *counter) != sign);
    *output = atoi(tempbuff);
	return 0;
}

short APRS_Packet::ParseAPRSISData(char* tInputBuffer, APRS_Packet* cTarget) {
    int i,ii;  // liczniki do petli
    int pos = 0;    // pozycja w przetwarzanej ramce
    int ctemp;
    char previous;  // poprzedni znak
    char tmp[2];
    char *src_t, *dst_t; // pomocnicze wskazniki do kopiowania danych pomiedzy tabelami
    if (*tInputBuffer == '#')
        return 1;
    src_t = tInputBuffer;
    ///////// Adres nadawcy
    dst_t = cTarget->SrcAddr;
    for(i = 0; i<=9 ;i++) {
        // przepisywanie adresu zrodla/nadawcy
        if( *(src_t + i) == '>') {
            i++;
            break;  // jezeli petla spotkala znak '>' to oznacza to koniec znaku nadawcy
        }
        else if(*(src_t + i) == '-') {
            // opcjonalne SSID nadawcy
            tmp[0] = *(src_t + i + 1);
            tmp[1] = *(src_t + i + 2);
            i++;
            ctemp = atoi(tmp);
            cTarget->SrcSSID = ctemp;
            do {
				if (*(src_t + i + pos) == 0x00 || (i + pos > buff_len))
					return -1;
                 // zwiekszanie licznika i do momentu dojscia do >
                 i++;
            } while (*(src_t + i + pos) != '>');
            i++;   // kolejne zwiekszanie o jeden zeby przeskoczyc na pierwszy znak kolejnego elementu
            break;
        }
        else {
            *(dst_t + i) = *(src_t + i);
        }
    }
    pos = i;
    /////// Adres przeznaczenia tu nie ma SSID
    dst_t = cTarget->DestAddr;
    for (i = 0; i <= 6; i++) {
        if (*(src_t + i + pos) == ',') {  // przecinek rozdziela poszczegolne
            i++;
            break;
        }
        else
           *(dst_t + i) = *(src_t + i + pos);
    }
    pos += i;
    ////// sciezka pakietowa
    ii = 0;
    while(ii <= 5 && (tmp[0] != 'q') && (tmp[1] != 'A')) {
        dst_t = cTarget->Path[ii].Call;
        // przetwarzanie maksymalnie 5 stopni do wyrazenia qA*
        for(i = 0; i<=9 ;i++) {
            if( *(src_t + i + pos) == ',') {
                i++;    // jezeli napotkano przecinek rozdzielajacy elementy to przesun na nastepny znak
                tmp[0] = *(src_t + i + pos);            // wpisywanie do bufora dwoch kolejnych znakow
                tmp[1] = *(src_t + i + pos + 1);
                break;  // i przerwij wykonywanie tej petli for
            }
            else if ( *(src_t + i + pos) == '-') {
                // SSID jezeli wystepuje
                tmp[0] = *(src_t + i + pos + 1);
                tmp[1] = *(src_t + i + pos + 2);
                ctemp = atoi(tmp);
                cTarget->Path[ii].SSID = ctemp;
                do {
					if (*(src_t + i + pos) == 0x00 || (i + pos > buff_len))
						return -1;
                    // zwiekszanie licznika i do momentu dojscia do przecinka
                    i++;
                } while (*(src_t + i + pos) != ',');
                i++;   // kolejne zwiekszanie o jeden zeby przeskoczyc na pierwszy znak kolejnego elementu
                tmp[0] = *(src_t + i + pos);            // wpisywanie do bufora dwoch kolejnych znakow
                tmp[1] = *(src_t + i + pos + 1);
                break;
            }
            else {
                // przepisywanie
                *(dst_t + i) = *(src_t + i + pos);
                tmp[0] = *(src_t + i + pos + 1);            // wpisywanie do bufora dwoch kolejnych znakow
                tmp[1] = *(src_t + i + pos + 2);
            }
        }
        pos += i;
        ii++;
    }
    cTarget->PathLng = ii - 1;      // dlugosc sciezki pakietowej
 //   pos += 2;
    i = 0;
    // przepisywanie qA*
    dst_t = cTarget->qOrigin;
    do {
		if (*(src_t + i + pos) == 0x00 || (i + pos > buff_len))
			return -1;
        if (i == 3) {
            *(dst_t + i + 1) = '\0';
            break;
        }
        *(dst_t + i) = *(src_t + i + pos);
        i++;
    } while (*(src_t + i + pos) != ',');
    pos += (i + 1);
    *(dst_t + i) = '\0';
    // przepisywanie adres oryginatora do IS
    dst_t = cTarget->ToISOriginator.Call;
    for (i = 0; i<=10 ;i++) {
        if( *(src_t + i + pos) == ':') {
            i++;    //przecinek oznacza poczatek tresci ramki
            break;
        }
        else if ( *(src_t + i + pos) == '-') {
            // SSID jezeli wystepuje
            tmp[0] = *(src_t + i + pos + 1);
            tmp[1] = *(src_t + i + pos + 2);
            ctemp = atoi(tmp);
            cTarget->Path[ii].SSID = ctemp;
            do {
				if (*(src_t + i + pos) == 0x00 || (i + pos > buff_len))
					return -1;				
                i++;
            } while (*(src_t + i + pos) != ':');
            i++;   // kolejne zwiekszanie o jeden zeby przeskoczyc na treść ramki
            break;
        }
        else
            *(dst_t + i) = *(src_t + i + pos);
    }
    pos += i;
    dst_t = cTarget->Data;
    for (i = 0; (i <= buff_len && *(src_t + i + pos) != '\n') ; i++)
        *(dst_t + i) = *(src_t + i + pos);
    return 0;
}

class connfrozen: public exception {
//    virtual const char* what() const throw() {
//        return "\n--- Brak komunikacji z serwerem\n";
//    }
}connfrz;

int EstablishConnectionToServer(int* sockfd, struct sockaddr_in* serv_addr, char* logintext) {
    int return_temp, nn;
    char receive_temp;
    struct timeval timeouts;    // structure witch holds timeout value for read command
    timeouts.tv_sec = 100;      // timeout value in second
    timeouts.tv_usec = 0;
    *sockfd = socket(AF_INET, SOCK_STREAM, 0);   // creating socket for connection
    setsockopt(*sockfd, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeouts, sizeof(timeouts));   // setting timeout val
    do {
        return_temp = connect(*sockfd,(struct sockaddr *) serv_addr,sizeof(*serv_addr));    // trying to connect
        if (return_temp < 0) {
            cout << "--- Nawiązywanie połaczenia zakończone niepowodzeniem. Kolejna próba za 10 sekund" << endl;
            sleep(10);      // waing for short while before next attempt
        }
    } while (return_temp != 0);
    cout << "--- Nawiązano połączenie z serwerem" <<endl;
    do {
        // waiting for hello message from APRS-IS server
        nn = read(*sockfd,&receive_temp,1);
        cout << receive_temp;
    } while (receive_temp != '\n');
    nn = write(*sockfd,logintext,strlen(logintext));  // sending login credentials
}

int main()
{
    ProgramConfig Config;   // Creating one copy of ProgramConfig Class
    int sockfd;         // socket file descriptor
    int portno, n, nn;
    struct sockaddr_in serv_addr;   // struct with server address and port
    struct hostent *server;         // wskaznik na strukture z wynikiem działania gethostbyname
    int return_temp;
    char receive_temp;
    char logintext[99];
    char Buffer[255];   // bufor na
    char* BufferPointer;    // wskaznik na aktualnie zapisywane miejsce w buforze
    APRS_Packet* packet;
    WXFromPacket* WX;       // dane pogodowe
    time_t currtime;
    int currtimeint;
    time_t last_server_comm;    // time of last data receiving from server
    int last_server_comm_int;
    char command[570];   // bufor do wywoływania zewnętrznych poleceń
    FILE *plik;             // wskaznik na generowany plik HTML
    struct tm* local;
    static const char mon_name[][13] = {
    "Stycznia", "Lutego", "Marca", "Kwietnia", "Maja", "Czerwca",
    "Lipca", "Sierpnia", "Wrzesnia", "Pazdziernika", "Listopada", "Grudnia"
    };

    Config.SetParameters();     // setting configuration parameters
    sprintf(logintext, "user %s pass %d vers WX2RRD 0.1.0 filter p/%s \r\n", Config.Call, Config.Pass, Config.MonitoredCall);
    server = gethostbyname(Config.APRSServerAddr); // translating domain name to IP
    if (server == NULL) {
        printf("--- Nie znaleziono serwera APRS-IS");
        return -1;
    }
    bzero((char *) &serv_addr, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;         // IPv4 address
    bcopy((char *)server->h_addr,
         (char *)&serv_addr.sin_addr.s_addr,
         server->h_length);             // kopiuje adres serwera ze struktury server do serv_addr
    serv_addr.sin_port = htons(Config.APRSServerPot);  // numer portu\

    EstablishConnectionToServer(&sockfd, &serv_addr, logintext);
    last_server_comm = time(NULL);
    last_server_comm_int = (int)last_server_comm;
    for(;;) {
        try {
		buff_len = 0;
        BufferPointer = Buffer; // ustawianie na poczatek bufora
        do {
            // Waiting for data
            currtimeint = (int)time(NULL);
            read(sockfd,&receive_temp,1);
            *BufferPointer++ = receive_temp;    // dodawanie znaku do bufora
            if (receive_temp == 0x00) {
                /*  Check when last data from APRS server was reveiced. Normally each server sends
                some ping messages in 30 sec interval. If connection become frozen this routine
                will reset it*/
                throw connfrz;
            }
			buff_len++;
        } while (receive_temp != '\n');
        *BufferPointer++ = '\0';        // adding NULL-terminator at the end of string
        cout << Buffer;
        last_server_comm_int = (int)time(NULL);     // updating time
        packet = new APRS_Packet;
        if (packet->ParseAPRSISData(Buffer, packet) == 0) {
            packet->PrintPacketData();
            WX = new WXFromPacket;
            if(WX->ParseData(packet) == 0) {
                currtime =time(NULL);
                currtimeint = (int)currtime;
                memset(command, 0x00, sizeof(command));
                sprintf(command, "rrdtool update %s %d:%f\0", Config.RRDSpeedPath, currtimeint, WX->wind_speed);
//                printf(command);
//                                printf("\r\n");
                system(command);
                memset(command, 0x00, sizeof(command));
                sprintf(command, "rrdtool update %s %d:%d\0",Config.RRDDirectionPath ,currtimeint, WX->wind_direction);
//                printf(command);
//                                printf("\r\n");
                system(command);
                memset(command, 0x00, sizeof(command));
                sprintf(command, "rrdtool update %s %d:%f\0",Config.RRDGustsPath ,currtimeint, WX->wind_gusts);
//                printf(command);
//                                printf("\r\n");
                system(command);
                memset(command, 0x00, sizeof(command));
                sprintf(command, "rrdtool graph %s -w 700 -h 370 -t \"Predkosc Wiatru\" -v \"m/s\" -l 1.0000e-1 -u 1.200e+1 -r --right-axis 1:0 --right-axis-label \"m/s\" --x-grid MINUTE:10:HOUR:1:HOUR:1:0:%%H:00 --start %d --end %d DEF:predkoscwiatru=%s:predkosc:AVERAGE DEF:szkwaly=%s:szkwaly:AVERAGE AREA:predkoscwiatru#FF0000:Srednia LINE2:szkwaly#0000FF:Porywy \0",Config.PNGSpeedPath ,currtimeint-36000, currtimeint, Config.RRDSpeedPath, Config.RRDGustsPath);
//                printf(command);
//                                printf("\r\n");
                system(command);
                memset(command, 0x00, sizeof(command));
                sprintf(command, "rrdtool graph %s -w 700 -h 280 -t \"Kierunek Wiatru\" -v \"stopnie\" -l 1 -u 3.6000e+2 --right-axis 1:0 --right-axis-label \"stopnie\" --x-grid MINUTE:10:HOUR:1:HOUR:1:0:%%H:00 --start %d --end %d DEF:kierunek=%s:kierunek:AVERAGE LINE1:kierunek#FF0000 \0",Config.PNGDirectionPath ,currtimeint-36000, currtimeint, Config.RRDDirectionPath);
//                printf(command);
//                                printf("\r\n");
                system(command);
                memset(command, 0x00, sizeof(command));
                if ((plik=fopen(Config.HTMLPath,"wt")) != NULL) {
                    fprintf(plik, " <!DOCTYPE html><HTML><head>\r\n<TITLE>Pogoda na Chełmie</TITLE> <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">");
                    fprintf(plik, "<style type=\"text/css\">td.dupa {	text-align: right;} td.dupa-druga {text-align: left;} td.dupa-trzecia{text-align: center;} table.dupa-trzecia {width: 870px;} p.wagina {font-style: italic;}</style></head>");
                    fprintf(plik, "<P><H2>Stacja Pogodowa SR9WXG -- Góra Chełm koło Grybowa</H2></P>\r\n");
                    fprintf(plik, "<table><tr><td class=dupa><b>Aktualna Prędkość Wiatru (średnia za 30 sekund):</b></td><td class=dupa-druga id=srednia> %.1f m/s </td></tr>\r\n", WX->wind_speed);
                    fprintf(plik, "<tr><td class=dupa><b>Aktualne Porywy (maksymalna szybkość przez ostatnie 30 sekund):</b></td><td class=dupa-druga id=porywy> %.1f m/s </td></tr>", WX->wind_gusts);
                    fprintf(plik, "<tr><td class=dupa><b>Aktualny Kierunek Meteo:</b></td><td class=dupa-druga id=kierunek> %d stopni ", WX->wind_direction);
                    if (WX->wind_direction <= 11 && WX->wind_direction >= 349)
                        fprintf(plik, "- z północy");
                    else if (WX->wind_direction <= 34 && WX->wind_direction > 11)
                        fprintf(plik, "- z północy-północnego wschodu");
                    else if (WX->wind_direction <= 56 && WX->wind_direction > 34)
                        fprintf(plik, "- z północnego wschodu");
                    else if (WX->wind_direction <= 79 && WX->wind_direction > 56)
                        fprintf(plik, "- ze wschodu-północnego wschodu");
                    else if (WX->wind_direction <= 101 && WX->wind_direction > 79)
                        fprintf(plik, "- ze wschodu");
                    else if (WX->wind_direction <= 124 && WX->wind_direction > 101)
                        fprintf(plik, "- ze wschodu-południowego wschodu");
                    else if (WX->wind_direction <= 146 && WX->wind_direction > 124)
                        fprintf(plik, "- z południowego wschodu");
                    else if (WX->wind_direction <= 169 && WX->wind_direction > 146)
                        fprintf(plik, "- z południa-południowego wschodu");
                    else if (WX->wind_direction <= 191 && WX->wind_direction > 169)
                        fprintf(plik, "- z południa");
                    else if (WX->wind_direction <= 214 && WX->wind_direction > 191)
                        fprintf(plik, "- z południa-południowego zachodu");
                    else if (WX->wind_direction <= 236 && WX->wind_direction > 214)
                        fprintf(plik, "- z południowego zachodu");
                    else if (WX->wind_direction <= 259 && WX->wind_direction > 236)
                        fprintf(plik, "- z zachodu-południowego zachodu");
                    else if (WX->wind_direction <= 281 && WX->wind_direction > 259)
                        fprintf(plik, "- z zachodu");
                    else if (WX->wind_direction <= 304 && WX->wind_direction > 281)
                        fprintf(plik, "- z zachodu-północnego zachodu");
                    else if (WX->wind_direction <= 327 && WX->wind_direction > 304)
                        fprintf(plik, "- z północnego zachodu");
                    else if (WX->wind_direction <= 349 && WX->wind_direction > 327)
                        fprintf(plik, "- z północy-północnego zachodu");
                    else;
                    fprintf(plik, "</td></tr></table>");
                    local = localtime(&currtime);
                    fprintf(plik, "<P class=wagina><b>Czas ostatniej aktualizacji: %3d %s %.2d:%.2d:%.2d</b> </P>", local->tm_mday, mon_name[local->tm_mon], local->tm_hour, local->tm_min, local->tm_sec);
                    fprintf(plik, "<table class=dupa-trzecia><td class=dupa-trzecia><a href=\"info.html\">Informacje o stacji i startowisku</a></td></table>\r\n");
                    fprintf(plik, "<img src=\"predkosc.png\">\r\n<br><img src=\"kierunek.png\">");
                     fprintf(plik, "<P class=wagina><b>Sponsoprzy i Dobrodzieje:</b> <ul><li>Polskie Stowarzyszenie Paralotniowe</li><li>Właściciel działki widokowej \"Pod Skalniakiem\" w Grybowie. Noclegi, ogniska, pikniki tel: +48 18 447 23 22</li><li>Akademicki Klub Lotniczy Politechniki Rzeszowskiej</li></ul></P>");
		    fprintf(plik, "<p>Strona wygenerowna przy pomocy programu APRS2RRD-0.0.3-08022014 <a href=\"http://ebc41.elektroda.eu/aprs/aprs2rrd/changelog\">CHANGELOG</a></p>");
                    fclose(plik);
                }
            }
            delete WX;
        }
        delete packet;
        bzero(Buffer, sizeof(Buffer));
        receive_temp = 0;
        }
        catch (connfrozen& e) {
            cout << endl << "--- Brak komunikacji z serwerem" << endl;
            close(sockfd);
            for (int i = 0; i<=0xDDD; i++);  // some delay
            EstablishConnectionToServer(&sockfd, &serv_addr, logintext);
            last_server_comm_int = (int)time(NULL);
        }
    }
       close(sockfd);   //zamykanie gniazda
    return 0;
}
